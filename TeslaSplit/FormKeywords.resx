<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="textBox1.Text" xml:space="preserve">
    <value>These are the keyword events you can use in your Split List:

sceneIndex: ###
  This is the room number you are currently in.
  Use a specific sceneIndex to split upon entering that room.
  Please refer to the Scenes help to see what scene corresponds to which room.
  
checkpointIndex: ##
  This is the checkpoint number within your current room.
  Use a specific checkpointIndex to split upon attaining it.
  
Scene: ### CheckPoint: ##
  A combination of sceneIndex and checkpointIndex.
  This will split on the specified scene AND checkpoint.
  
orbsFound: xxxxxxxx
  This is the code for the current list of collected scrolls.
  If you know the specific code to watch for, this will split upon attaining it.
  
ScrollCount: ##
  While collecting scrolls, a program counter will increment.
  This will split when the total collected reaches the listed number.
  
CollectScroll
  This will split when the scroll counter increases.
  
openBarriers: ########
  This is the hash for the list of opened doors.
  If you know the specific hash to watch for, this will split upon attaining it.

openBarriers: 0
  This value is briefly set at the beginning of the game at the end of the opening cutscene.
  Start with this at the beginning of your split list if you want to start the timer automatically.

BarrierChange
  This will split when openBarriers changes its value.
  
glove: 1
  This will split upon collecting the glove.
  
blink: 1
  This will split upon collecting the boots.
  
suit: 1
  This will split upon collecting the cloak.
  
staff: 1
  This will split upon collecting the staff.
  
ItemPickup
  This will split upon collecting the glove, boots, cloak, or staff.

defeatedBosses: 1
  This will split when Fernus is defeated.
  
defeatedBosses: 3
  This will split when Faradeus is defeated.
  
defeatedBosses: 7
  This will split when Oleg is defeated.
  
defeatedBosses: 15
  This will split when Guerickes Orb is defeated.

Note: The numbers above will only work if the bosses are defeated in the intended order.
defeatedBosses assigns each boss a number. Fernus is 1, Faradeus is 2, Oleg is 4, and Guerickes Orb is 8.
Add the numbers of the defeated bosses together. For example if you skip Faradeus, then the split for Oleg
becomes "defeatedBosses: 5" and Guerickes Orb becomes "defeatedBosses: 13." But to make things simpler...

DefeatedBoss
  This will split when defeatedBosses changes its value.

gameComplete: 1
  This will split upon returning to the main menu after the Ende.

Ende
  Usefull for ending the run, it uses the fact that you only do a certain amount of EBH in last rooms of the game AND that the last EBH is always the moment you loose control over the character.
  If you are doing any category that is not 100% this will split on the second EBH that you'll perform after entering King's room.
  If you are doing a 100% run, this will split on the first EBH that you'll do after the final home sceneIndex.</value>
  </data>
</root>